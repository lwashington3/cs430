%! Author = Len Washington III
%! Date = 9/12/2023

% Preamble
\documentclass[12pt]{report}

% Packages
\usepackage[17]{cs430lecture}

% Document
\begin{document}

%<*Lecture-Activity-17>

\section{When can you use Dynamic Programming?}\label{sec:when-can-you-use-dynamic-programming?}
DP computes recurrences efficiently by storing partial results. Thus DP can only be efficient when there are not too many partial results to compute. There are $n!$ permutations of an $n$-element set - we cannot use DP to store the best solution to each sub-permutation. There are $2^n$ subsets of an $n$-element set, we cannot use dynamic programming to store the best solution for each subset.\\

Dynamic Programming works best on objects which are linearly ordered and cannot be rearranged, so the number of partial results is not exponential. Characters in a string, matrices in a chain, the left-to-right order of the leaves in a BST. One commonality to all the dynamic programming solutions we explored is that all the problems had some sort of ordering restriction. Here is an example that does not. Because of the constraint on the total weight limit, it is not an exponential enumerate all the subsets of an $n$-element set.

\section{0-1 Knapsack Problem}\label{sec:0-1-knapsack-problem}
Given $N$ items and a total weight limit $W$, $v_{i}$ is the value and $w_{i}$ is the weight of item $i$, maximize the total value of items taken.

The dynamic programming algorithm computes entries of a matrix $C[0\dots N, 0\dots W]$

$C[i,j] = $ the optimal value of the items put into the knapsack from among items $\{ 1, 2, \dots, i\}$ with total weight $\leq j$ with $C[0,?] = C[?,0] = 0$

\begin{enumerate}[label=\arabic*.]
    \item When you think about calculating $C[i,j]$ there are two options. The $i$th item is in that optimal answer or is not. Write the recurrence relation.
	\item Write pseudocode to fill in the $C[i,j]$ matrix, use your answer from \#7.
\end{enumerate}

\openingquestions[Greedy Algorithms]

\begin{enumerate}[label=\arabic*.,start=3]
    \item Briefly explain what two properties a problem must have so that a greedy algorithm approach will work.
	\item A good cashier gives change using a greedy algorithm to minimize the number of coins they give back. Explain this greedy algorithm.
	\item For what types of optimization problems does optimal substructure fail?
\end{enumerate}

\section{Activity Selector Problem}\label{sec:activity-selector-problem}
Given a set $S$ of $n$ activities each with start $S_{i}$, Finish $F_{i}$, find the maximum set of Compatible Activities (non-overlapping). (or could be jobs scheduled with fixed start and end times instead of meetings)
\begin{enumerate}[label=\arabic*.,start=6]
    \item The brute force approach would be to find all possible subsets of $n$ activities, eliminate the ones with non-compatible meetings, and find the largest subset. How many subsets are there?
	\item Probe the Activity Selector Problem has optimal substructure (using similar proof by contradiction approach that we used for dynamic programming: assume you have an optimal answer, remove something to get to the largest sub-problem, show that the sub-problem must also be solved optimally).
\end{enumerate}

%</Lecture-Activity-17>

\end{document}