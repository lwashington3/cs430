%! Author = Len Washington III
%! Date = 8/12/2023

% Preamble
\documentclass[1]{cs430homework}

% Document
\begin{document}

\maketitle

\begin{enumerate}[label=\arabic*.]
    \item (5 points) Let $A[1 \dots n]$ be an array of $n$ distinct numbers. If $i < j$ and $A[i] > A[j]$, then the pair $(i, j)$ is called an inversion of $A$.\label{prb:1}
	\begin{enumerate}[label=\arabic{enumi}\alph*)]
	    \item List the five inversions of the array $<2, 3, 8, 6, 1>$.
		\item What array with elements from the set $\left\{1, 2, \dots, n\right\}$ has the most inversions? How many does it have?
		\item What is the relationship between the running time of insertion sort and the number of inversions in the input array? Justify your answer.
	\end{enumerate}
	\item (5 points) Communication security is extremely important in computer networks, and one way many network protocols achieve security is to encrypt messages. Typical \emph{cryptographic} schemes for the secure transmission of messages over such networks are based on the fact that no efficient algorithms are known for factoring large integers. Hence, if we can represent a secret message by a large prime number $p$, we can transmit over the network the number $r=p*q$, where $q>p$ is another large prime number that acts as the \emph{encryption key}. An eavesdropper who obtains the transmitted number $r$ on the network would have to factor $r$ in order to figure out the secret message $p$.\\

	Using factoring to figure out a message is very difficult without knowing the encryption key $q$. To understand why, consider the following naive factoring algorithm:

	For every integer $p$ such that $1<p<r$, check if $p$ divides $r$. If so, print ``The secret message is $p$!'' and stop; if not, continue.
	\begin{enumerate}[label=\arabic{enumi}\alph*)]
	    \item Suppose that the eavesdropper uses the above algorithm and has a computer that can carry out in 1 microsecond (1 millionth of a second) a division between two integers of up to 100 bits each. Give an estimate of the time that it will take in the worst case to decipher the secret message if $r$ has 100 bits.
		\item What is the worst-case time complexity of the above algorithm? Since the input to the algorithm is just one large number $r$, assume that the input size $n$ is the number of bytes needed to store $r$, that is, $n = (\log_{2}r) /8$, and that each division takes time $O(n)$.
	\end{enumerate}
	\item (5 points) Bubblesort can be described as follows: Consider sorting (in increasing order) $n$ numbers by comparing the 1st and 2nd number and swapping them if they are out of order, then comparing the 2nd and 3rd number and swapping them if necessary, $\dots$, comparing the $(n-1)$ st and $n$th number and swapping them if necessary. Then do this again for $n-1$ numbers, then $n-2$ numbers, etc. When no exchanges are required on some pass, the file is sorted.\\

	A different version of bubble sort keeps track of where the last swap occurred, and on the next pass, it will not go past this point. If the last change was made in the swap of locations $i$ and $i+1$, the next pass will not look at any elements past location $i$.
	\begin{enumerate}[label=\arabic{enumi}\alph*)]
	    \item Write iterative pseudocode for this new version of Bubblesort.
		\item Write a short paragraph that explains exactly why this new version of bubble sort will work.
		\item How does this new version of bubble sort does change the worst-case runtime analysis? Can you state what particular input will give worst-case runtime?  Give a detailed explanation of what is involved in calculating the worst-case runtime analysis.
	\end{enumerate}
	\item (5 points) Give an algorithm that determines the number of inversions (see \hyperref[prb:1]{problem \#1}) in any permutation on $n$ elements in $\Theta(n \lg n)$ worst-case time. (Hint: Modify merge sort.)
	\item (5 points) Prove, by induction on $k$, that level $k$ of a binary tree has less than or equal to 2$k$ nodes (root level has $k=0$).
	\item (5 points)
	\begin{enumerate}[label=\arabic{enumi}\alph*)]
	    \item Describe the final returned value of the recursive algorithm below on a general input $N$:
		\begin{algorithm}[H]
			\label{alg:6a}
			\begin{algorithmic}[1]
			\Function{X}{int $N$}\Comment{Return type: int}
				\If{N $\leq$ 1}
					\State \Return 1
				\Else
					\State \Return X(N-1) + X(N-1)
				\EndIf
			\EndFunction
			\end{algorithmic}
		\end{algorithm}
		\item Perform asymptotic analysis, find the recurrence relation, and give big-O bounds on the running time of $X$.
		\item The following algorithm ``Y'' generates the same result (verify this). Perform asymptotic analysis, find the recurrence relation, and give big-O bounds on the running time of Y.
		\begin{algorithm}[H]
			\label{alg:6c}
			\begin{algorithmic}[1]
			\Function{y}{int N}\Comment{Return Type: int}
				\If{N $\leq$ 1}
					\Return 1
				\Else{}
					\State temp $\gets$ Y(N-1)
					\State \Return (temp + temp)
				\EndIf
			\EndFunction
			\end{algorithmic}
		\end{algorithm}
	\end{enumerate}
	\item (5 points)
		\begin{algorithm}[H]
			\label{alg:7a}  % FIXME: Bauer said he'd tell us when he's fixed the code. Check back later.
			\begin{algorithmic}[1]
			\Function{foo}{int A[], int start, int end}\Comment{Initial call \Call{foo}{array, 0, array.length}}
				\If{end $\leq$ 1}
					\Return
				\EndIf
				\If{A[start] $>$ A[end-1]}
					\State swap A[start] and A[end-1]
				\EndIf
				\State \Call{foo}{A, start+1, end-2}
				\If{A[start] $>$ A[start+1]}
					\State swap A[start] and A[start+1]
				\EndIf
				\State \Call{foo}{A, start+1, end-1}
			\EndFunction
			\end{algorithmic}
		\end{algorithm}
		Write a recurrence describing the number of times the algorithm compares two members of array $A$, measured as a function of the array length $n$. You do not need to solve the recurrence relation exactly, but state if the solution is linear growth, polynomial growth or exponential growth.
	\item (5 points) Give big-O bounds for $T(n)$ in each of the following recurrences. Use induction, iteration or Master Theorem.
	\begin{enumerate}[label=\arabic{enumi}\alph*)]
	    \item $T(n)=2T(n/8)+n^{\frac{1}{3}}$
	    \item $T(n)=T(n-2)+n$
	    \item $T(n)=7T(n/3)+n^{2}$
	\end{enumerate}
\end{enumerate}

\end{document}